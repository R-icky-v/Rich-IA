import telebot
from telebot import types
from dotenv import load_dotenv
import os
from datetime import datetime
import json
import threading
import time
import shutil
import requests 

load_dotenv()
bot = telebot.TeleBot("8149029077:AAExO4Uv4RFbOuayc1plb6to--OsrV3xv9E")
# Sistema Keep-Alive para Render
KEEP_ALIVE_INTERVAL = 600  # 10 minutos (m√°s seguro que 13)
KEEP_ALIVE_URL = None  # Se configurar√° autom√°ticamente
# Estructuras en memoria:
user_notes = {}   # { user_id: [ {"tag": str, "title": str, "text": str, "ts": datetime}, ... ] }
user_names = {}   # { user_id: "Nombre" }
user_temp = {}    # { user_id: {"pending_tag": str, "pending_title": str} }

# Etiquetas disponibles con sus iconos espec√≠ficos
TAG_ICONS = {
    "Trabajo": "üíº",
    "Estudio": "üìö",
    "Personal": "üè†",
    "Emprendimiento": "üöÄ",
    "Amor": "‚ù§Ô∏è",
    "Social": "üë•"
}

# Sistema de respaldo mejorado
BACKUP_DIR = "backups"
MAIN_BACKUP_FILE = os.path.join(BACKUP_DIR, "rich_ai_data_backup.json")
BACKUP_INTERVAL = 300  # Segundos (5 minutos)
BACKUP_VERSIONS = 5    # N√∫mero de versiones de respaldo a mantener
SAVE_ON_CHANGES = True # Guardar en cambios importantes adem√°s del intervalo

# Sistema de im√°genes - Directorio y rutas de im√°genes
# Estableciendo rutas absolutas para evitar problemas
BASE_DIR = os.path.dirname(os.path.abspath(__file__))
IMAGES_DIR = os.path.join(BASE_DIR, "images")

# Definici√≥n de rutas absolutas para las im√°genes
RICH_WELCOME_IMG = os.path.join(IMAGES_DIR, "rich_welcome.png")
RICH_THINKING_IMG = os.path.join(IMAGES_DIR, "rich_thinking.png")
RICH_SUCCESS_IMG = os.path.join(IMAGES_DIR, "rich_success.png")
RICH_SAD_IMG = os.path.join(IMAGES_DIR, "rich_sad.png")

# Asegurar que los directorios existan
if not os.path.exists(BACKUP_DIR):
    os.makedirs(BACKUP_DIR)
if not os.path.exists(IMAGES_DIR):
    os.makedirs(IMAGES_DIR)
    print(f"‚ö†Ô∏è El directorio de im√°genes no exist√≠a y ha sido creado: {IMAGES_DIR}")
    print("Por favor coloca las im√°genes necesarias en este directorio antes de continuar.")

# Funci√≥n para enviar mensajes con im√°genes
def send_message_with_image(chat_id, text, image_path, reply_markup=None, parse_mode="Markdown"):
    """
    Env√≠a un mensaje con una imagen adjunta

    Args:
        chat_id: ID del chat
        text: Texto del mensaje
        image_path: Ruta a la imagen a enviar
        reply_markup: Teclado opcional
        parse_mode: Modo de parseo del texto

    Returns:
        Message: Objeto mensaje enviado
    """
    try:
        if os.path.exists(image_path):
            with open(image_path, 'rb') as photo:
                return bot.send_photo(
                    chat_id, 
                    photo, 
                    caption=text, 
                    parse_mode=parse_mode,
                    reply_markup=reply_markup
                )
        else:
            print(f"‚ö†Ô∏è Imagen no encontrada: {image_path}")
            # Caer de vuelta a env√≠o de mensaje sin imagen
            return bot.send_message(
                chat_id,
                text,
                parse_mode=parse_mode,
                reply_markup=reply_markup
            )
    except Exception as e:
        print(f"‚ùå Error al enviar imagen {image_path}: {e}")
        # En caso de error, enviar solo el mensaje
        return bot.send_message(
            chat_id,
            text,
            parse_mode=parse_mode,
            reply_markup=reply_markup
        )

# --- SISTEMA DE RESPALDO MEJORADO ---
def save_backup(force_rotation=False):
    """Guarda los datos en un archivo JSON como respaldo con sistema de rotaci√≥n"""
    backup_data = {
        "user_notes": {},
        "user_names": user_names,
        "backup_timestamp": datetime.now().strftime("%Y-%m-%d %H:%M:%S")
    }

    # Convertir los objetos datetime a string para serializaci√≥n JSON
    for user_id, notes in user_notes.items():
        backup_data["user_notes"][str(user_id)] = []
        for note in notes:
            note_copy = note.copy()
            note_copy["ts"] = note_copy["ts"].strftime("%Y-%m-%d %H:%M:%S")
            backup_data["user_notes"][str(user_id)].append(note_copy)

    try:
        # Primero guardar en un archivo temporal para evitar corrupci√≥n
        temp_file = os.path.join(BACKUP_DIR, "temp_backup.json")
        with open(temp_file, 'w', encoding='utf-8') as f:
            json.dump(backup_data, f, ensure_ascii=False, indent=2)

        # Si el guardado fue exitoso, mover el archivo temporal al archivo principal
        shutil.move(temp_file, MAIN_BACKUP_FILE)

        # Realizar rotaci√≥n de respaldos si es necesario
        if force_rotation or datetime.now().hour % 6 == 0:  # Rotar cada 6 horas o cuando se fuerce
            rotate_backups()

        print(f"‚úÖ Respaldo guardado: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")
        return True
    except Exception as e:
        print(f"‚ùå Error al guardar respaldo: {e}")
        return False

def rotate_backups():
    """Crea un sistema de rotaci√≥n de respaldos para mantener m√∫ltiples versiones"""
    try:
        # Mover versiones antiguas
        for i in range(BACKUP_VERSIONS-1, 0, -1):
            old_backup = os.path.join(BACKUP_DIR, f"rich_ai_data_backup.{i}.json")
            new_backup = os.path.join(BACKUP_DIR, f"rich_ai_data_backup.{i+1}.json")
            if os.path.exists(old_backup):
                shutil.move(old_backup, new_backup)

        # Copiar el respaldo actual como versi√≥n 1
        if os.path.exists(MAIN_BACKUP_FILE):
            backup_1 = os.path.join(BACKUP_DIR, "rich_ai_data_backup.1.json")
            shutil.copy2(MAIN_BACKUP_FILE, backup_1)

        print(f"üîÑ Rotaci√≥n de respaldos completada: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")
    except Exception as e:
        print(f"‚ö†Ô∏è Error en rotaci√≥n de respaldos: {e}")

def load_backup():
    """Carga los datos desde el archivo de respaldo con sistema de recuperaci√≥n"""
    global user_notes, user_names

    if not os.path.exists(MAIN_BACKUP_FILE):
        # Intentar buscar en versiones de respaldo si el principal no existe
        backup_found = False
        for i in range(1, BACKUP_VERSIONS + 1):
            backup_file = os.path.join(BACKUP_DIR, f"rich_ai_data_backup.{i}.json")
            if os.path.exists(backup_file):
                print(f"‚ö†Ô∏è Respaldo principal no encontrado. Intentando recuperar versi√≥n {i}.")
                if load_backup_file(backup_file):
                    # Si se recuper√≥ correctamente, guardar como archivo principal
                    shutil.copy2(backup_file, MAIN_BACKUP_FILE)
                    backup_found = True
                    break

        if not backup_found:
            print("‚ö†Ô∏è No se encontr√≥ ning√∫n archivo de respaldo v√°lido. Iniciando con datos vac√≠os.")
            return False
    else:
        return load_backup_file(MAIN_BACKUP_FILE)

def load_backup_file(file_path):
    """Carga un archivo de respaldo espec√≠fico"""
    global user_notes, user_names

    try:
        with open(file_path, 'r', encoding='utf-8') as f:
            backup_data = json.load(f)

        # Restaurar nombres de usuario
        user_names = backup_data.get("user_names", {})

        # Restaurar notas con conversi√≥n de string a datetime
        notes_data = backup_data.get("user_notes", {})
        for user_id_str, notes in notes_data.items():
            user_id = int(user_id_str)  # Convertir ID de string a int
            user_notes[user_id] = []
            for note in notes:
                note_copy = note.copy()
                note_copy["ts"] = datetime.strptime(note_copy["ts"], "%Y-%m-%d %H:%M:%S")
                user_notes[user_id].append(note_copy)

        backup_time = backup_data.get("backup_timestamp", "desconocido")
        print(f"‚úÖ Datos restaurados desde respaldo ({backup_time}): {len(user_names)} usuarios, {sum(len(notes) for notes in user_notes.values())} notas")
        return True
    except Exception as e:
        print(f"‚ùå Error al cargar respaldo {file_path}: {e}")
        return False

def backup_scheduler():
    """Funci√≥n para programar respaldos peri√≥dicos con manejo de errores"""
    consecutive_failures = 0
    while True:
        try:
            time.sleep(BACKUP_INTERVAL)
            success = save_backup(False)  # Respaldo normal

            if success:
                consecutive_failures = 0
            else:
                consecutive_failures += 1

            # Si hay muchos fallos consecutivos, forzar rotaci√≥n
            if consecutive_failures >= 3:
                print("‚ö†Ô∏è M√∫ltiples fallos de respaldo detectados. Forzando rotaci√≥n.")
                save_backup(True)  # Forzar rotaci√≥n
                consecutive_failures = 0

        except Exception as e:
            print(f"‚ùó Error cr√≠tico en el planificador de respaldos: {e}")
            time.sleep(60)  # Esperar un minuto antes de reintentar en caso de error cr√≠tico

def keep_alive_scheduler():
    """Funci√≥n para mantener el servicio activo enviando pings peri√≥dicos"""
    global KEEP_ALIVE_URL
    
    # Configurar URL autom√°ticamente desde variable de entorno
    if not KEEP_ALIVE_URL:
        # Priorizar la URL de Render autom√°tica
        render_external_url = os.environ.get("RENDER_EXTERNAL_URL")
        app_name = os.environ.get("RENDER_SERVICE_NAME") 
        
        if render_external_url:
            KEEP_ALIVE_URL = render_external_url
            print(f"üåê URL keep-alive configurada autom√°ticamente: {KEEP_ALIVE_URL}")
        elif app_name:
            KEEP_ALIVE_URL = f"https://{app_name}.onrender.com"
            print(f"üåê URL keep-alive generada desde nombre del servicio: {KEEP_ALIVE_URL}")
        else:
            print("‚ö†Ô∏è IMPORTANTE: No se pudo configurar la URL autom√°ticamente.")
            print("‚ö†Ô∏è Configura la variable RENDER_EXTERNAL_URL en Render o actualiza KEEP_ALIVE_URL manualmente")
            return  # Salir si no se puede configurar la URL
    
    consecutive_failures = 0
    print(f"üîÑ Keep-alive iniciado. URL objetivo: {KEEP_ALIVE_URL}")
    
    while True:
        try:
            time.sleep(KEEP_ALIVE_INTERVAL)
            
            # Hacer ping al endpoint de salud
            response = requests.get(f"{KEEP_ALIVE_URL}/health", timeout=30)
            
            if response.status_code == 200:
                print(f"‚úÖ Keep-alive exitoso: {datetime.now().strftime('%H:%M:%S')}")
                consecutive_failures = 0
            else:
                consecutive_failures += 1
                print(f"‚ö†Ô∏è Keep-alive fall√≥ (c√≥digo {response.status_code}). Fallos consecutivos: {consecutive_failures}")
                
        except requests.RequestException as e:
            consecutive_failures += 1
            print(f"‚ùó Error en keep-alive: {str(e)[:100]}... Fallos consecutivos: {consecutive_failures}")
            
        except Exception as e:
            print(f"‚ùó Error cr√≠tico en keep-alive: {e}")
            time.sleep(60)  # Esperar m√°s tiempo en caso de error cr√≠tico
            
        # Si hay muchos fallos, esperar m√°s tiempo antes del siguiente intento
        if consecutive_failures >= 5:  # Reducido de 3 a 5 para ser menos agresivo
            print("‚ö†Ô∏è M√∫ltiples fallos de keep-alive. Esperando 3 minutos adicionales.")
            time.sleep(180)  # 3 minutos adicionales (reducido de 5)
            consecutive_failures = 0  # Resetear contador despu√©s de la pausa

# --- NUEVAS FUNCIONES PARA VISTA DE TARJETAS INTERACTIVAS ---
def get_user_tags_with_notes(user_id):
    """Obtiene las etiquetas que tienen notas para un usuario espec√≠fico"""
    notas = user_notes.get(user_id, [])
    tags_with_notes = {}
    
    for nota in notas:
        tag = nota['tag']
        if tag not in tags_with_notes:
            tags_with_notes[tag] = []
        tags_with_notes[tag].append(nota)
    
    return tags_with_notes

def make_tags_view_menu(user_id):
    """Crea el men√∫ de etiquetas que tienen notas guardadas"""
    tags_with_notes = get_user_tags_with_notes(user_id)
    
    if not tags_with_notes:
        return None
        
    kb = types.InlineKeyboardMarkup(row_width=2)
    
    for tag in tags_with_notes.keys():
        icon = TAG_ICONS.get(tag, "üîñ")
        count = len(tags_with_notes[tag])
        kb.add(types.InlineKeyboardButton(
            f"{icon} {tag} ({count})", 
            callback_data=f"view_tag_{tag}"
        ))
    
    kb.add(types.InlineKeyboardButton("‚Ü©Ô∏è Volver al men√∫", callback_data="back_to_main"))
    return kb

# --- NUEVAS FUNCIONES PARA VISTA DE TARJETAS DE ELIMINACI√ìN ---
def make_delete_tags_menu(user_id):
    """Crea el men√∫ de etiquetas para eliminaci√≥n (vista de tarjetas)"""
    tags_with_notes = get_user_tags_with_notes(user_id)
    
    if not tags_with_notes:
        return None
        
    kb = types.InlineKeyboardMarkup(row_width=2)
    
    for tag in tags_with_notes.keys():
        icon = TAG_ICONS.get(tag, "üîñ")
        count = len(tags_with_notes[tag])
        kb.add(types.InlineKeyboardButton(
            f"{icon} {tag} ({count})", 
            callback_data=f"delete_tag_{tag}"
        ))
    
    kb.add(types.InlineKeyboardButton("‚Ü©Ô∏è Volver al men√∫", callback_data="back_to_main"))
    return kb

def make_delete_notes_by_tag_menu(user_id, tag):
    """Crea el men√∫ de notas para eliminaci√≥n por etiqueta espec√≠fica"""
    notas = user_notes.get(user_id, [])
    notes_in_tag = [nota for nota in notas if nota['tag'] == tag]
    
    if not notes_in_tag:
        return None
    
    kb = types.InlineKeyboardMarkup(row_width=1)
    
    for idx, nota in enumerate(notes_in_tag):
        # Crear snippet del t√≠tulo (m√°ximo 35 caracteres para dar espacio al n√∫mero y fecha)
        title_snippet = (nota['title'][:32] + "...") if len(nota['title']) > 35 else nota['title']
        date_str = nota['ts'].strftime("%d/%m")
        
        # Encontrar el √≠ndice global de la nota para eliminar
        global_idx = user_notes[user_id].index(nota)
        
        kb.add(types.InlineKeyboardButton(
            f"üóëÔ∏è {idx + 1}. {title_snippet} - {date_str}",
            callback_data=f"confirm_delete_{global_idx}"
        ))
    
    kb.add(types.InlineKeyboardButton("‚Ü©Ô∏è Volver a etiquetas", callback_data="delete_note"))
    kb.add(types.InlineKeyboardButton("üè† Men√∫ principal", callback_data="back_to_main"))
    return kb

def make_notes_by_tag_menu(user_id, tag):
    """Crea el men√∫ de notas para una etiqueta espec√≠fica"""
    notas = user_notes.get(user_id, [])
    notes_in_tag = [nota for nota in notas if nota['tag'] == tag]
    
    if not notes_in_tag:
        return None
    
    kb = types.InlineKeyboardMarkup(row_width=1)
    
    for idx, nota in enumerate(notes_in_tag):
        # Crear snippet del t√≠tulo (m√°ximo 40 caracteres)
        title_snippet = (nota['title'][:37] + "...") if len(nota['title']) > 40 else nota['title']
        date_str = nota['ts'].strftime("%d/%m")
        
        # Crear identificador √∫nico para la nota
        note_id = f"{user_id}_{tag}_{idx}"
        
        kb.add(types.InlineKeyboardButton(
            f"üìù {title_snippet} - {date_str}",
            callback_data=f"view_note_{note_id}"
        ))
    
    kb.add(types.InlineKeyboardButton("‚Ü©Ô∏è Volver a etiquetas", callback_data="show_notes"))
    kb.add(types.InlineKeyboardButton("üè† Men√∫ principal", callback_data="back_to_main"))
    return kb

def format_full_note(note):
    """Formatea una nota completa para mostrar todo su contenido"""
    title = note['title']
    tag = note['tag']
    text = note['text']
    ts = note['ts'].strftime("%Y-%m-%d %H:%M")
    tag_icon = TAG_ICONS.get(tag, "üîñ")

    formatted_note = (
        "‚ú® **Aqu√≠ tienes tu nota completa** ‚ú®\n"
        "‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ\n"
        f"üìå **T√≠tulo:** {title}\n"
        f"{tag_icon} **Etiqueta:** {tag}\n"
        f"üïí **Fecha:** {ts}\n"
        "‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ\n\n"
        f"üìù **Contenido:**\n{text}\n\n"
        "‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ\n"
        "¬°Gracias por confiar en Rich AI! üåü"
    )

    return formatted_note

def find_note_by_id(user_id, note_id):
    """Encuentra una nota espec√≠fica usando el ID generado"""
    try:
        # Extraer informaci√≥n del note_id
        parts = note_id.split('_')
        if len(parts) < 3:
            return None
            
        stored_user_id = int(parts[0])
        tag = '_'.join(parts[1:-1])  # Permitir tags con guiones bajos
        note_index = int(parts[-1])
        
        if stored_user_id != user_id:
            return None
            
        notas = user_notes.get(user_id, [])
        notes_in_tag = [nota for nota in notas if nota['tag'] == tag]
        
        if 0 <= note_index < len(notes_in_tag):
            return notes_in_tag[note_index]
            
    except (ValueError, IndexError):
        return None
    
    return None

# --- FUNCIONES PARA PRESENTACI√ìN MEJORADA ---
def format_note(note, index=None):
    """Crea una presentaci√≥n de nota sin formato tarjeta pero con emojis"""
    title = note['title']
    tag = note['tag']
    text = note['text']
    ts = note['ts'].strftime("%Y-%m-%d %H:%M")
    tag_icon = TAG_ICONS.get(tag, "üîñ")

    # Crear un snippet del texto (primeros 100 caracteres para m√°s contenido)
    snippet = text[:100] + "..." if len(text) > 100 else text

    # Construir el mensaje
    index_text = f"{index}. " if index is not None else ""

    formatted_note = (
        "‚ú® ¬°Aqu√≠ tienes tu nota guardada! ‚ú®\n"
        "‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ\n"
        f"üî¢‚Äã Numero : {index_text}\n"
        f"üìå Titulo : **{title}**\n"
        f"{tag_icon} Etiqueta : {tag}\n"
        f"üìù Contenido : {snippet}\n"
        f"üïí Guardada el : {ts}\n"
        "¬°Espero que te sea √∫til! üòä\n"
        "‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ\n"
    )

    return formatted_note

def create_search_results(notes, date_str=None, name=None):
    """Crea una presentaci√≥n mejorada para resultados de b√∫squeda"""
    if not notes:
        if date_str:
            return f"¬°Hola! üòä No encontr√© ninguna nota para el {date_str}. ¬°Quiz√°s es un buen d√≠a para planificar algo nuevo! üìù‚ú®"
        return "¬°Hola! üòº Parece que a√∫n no tienes ninguna nota. ¬°An√≠mate a escribir tu primera idea! üí°"

    header = ""
    if date_str:
        header = f"¬°Hola, {name}! üòä Aqu√≠ tienes las notas que encontr√© para el {date_str}:\n\n"
    elif name:
        header = f"üìã ¬°Hola üòä, {name}! Aqu√≠ est√°n todas tus notas guardadas:\n\n"

    formatted_notes = []
    for i, nota in enumerate(notes, start=1):
        formatted_notes.append(format_note(nota, i))

    footer = "\n\n‚ú® ¬°Sigue organizando tu √©xito con Rich AI! üåü ¬°Siempre aqu√≠ para ti! ü§ó"

    return header + "\n\n".join(formatted_notes) + footer

# --- HELPERS ---
def make_main_menu(user_name):
    kb = types.InlineKeyboardMarkup()
    # Primera fila: a√±adir y ver
    kb.add(
        types.InlineKeyboardButton("üìù A√±adir nota", callback_data="add_note"),
        types.InlineKeyboardButton("üìã Ver notas", callback_data="show_notes")
    )
    # Segunda fila: borrar y buscar
    kb.add(
        types.InlineKeyboardButton("üóëÔ∏è Borrar nota", callback_data="delete_note"),
        types.InlineKeyboardButton("üîç Buscar (Fecha)", callback_data="search_note")
    )
    # Tercera fila: sobre nosotros
    kb.add(
        types.InlineKeyboardButton("üí° Sobre m√≠", callback_data="about_me")
    )
    return kb

def make_tags_menu():
    kb = types.InlineKeyboardMarkup(row_width=2)
    for tag in TAG_ICONS.keys():
        icon = TAG_ICONS[tag]
        kb.add(types.InlineKeyboardButton(f"{icon} {tag}", callback_data=f"tag{tag}"))
    return kb

# --- HANDLER PARA NOMBRE ---
def process_name(message):
    user_id = message.from_user.id
    name = message.text.strip()
    if not name:
        msg = bot.send_message(
            message.chat.id,
            "‚ùó Error: No recib√≠ tu nombre. Por favor, vuelve a intentarlo. ü•∫",
            parse_mode="Markdown"
        )
        bot.register_next_step_handler(msg, process_name)
        return
    user_names[user_id] = name
    user_notes.setdefault(user_id, [])

    # Guardar respaldo cuando se a√±ade un nuevo usuario
    if SAVE_ON_CHANGES:
        save_backup()

    welcome_text = (
    f"¬°Hola, {name}! üòä ¬°Qu√© alegr√≠a tenerte por aqu√≠!\n\n"
    "Soy Rich IA, tu compa√±ero virtual listo para ayudarte a organizar tus ideas y ser tu apoyo en el d√≠a a d√≠a. üíñ\n"
    "Imagina este espacio como tu bloc de notas personal donde cada pensamiento es bienvenido y cuidado. ‚ú®\n\n"
    "¬øQu√© te gustar√≠a hacer hoy? ¬°Estoy aqu√≠ para escucharte! ü§ó"
    )
    # Usar imagen de bienvenida
    send_message_with_image(
        message.chat.id,
        welcome_text,
        RICH_WELCOME_IMG,
        reply_markup=make_main_menu(name),
        parse_mode="Markdown"
    )

# --- HANDLERS PRINCIPALES ---
@bot.message_handler(commands=['start', 'help'])
def send_welcome(message):
    user_id = message.from_user.id
    if user_id not in user_names:
        # Primera interacci√≥n - usar imagen de bienvenida
        msg = send_message_with_image(
            message.chat.id,
            "¬°Hola! üòº ¬°Qu√© genial tenerte aqu√≠! üòä Soy Rich IA, tu nuevo amigo y asistente de notas.\n\n"
            "Para que pueda conocerte mejor y hacer nuestra experiencia m√°s personalizada, ¬øme dir√≠as tu nombre? üëÄ‚Äã ",
            RICH_WELCOME_IMG,
            parse_mode="Markdown"
        )
        bot.register_next_step_handler(msg, process_name)
    else:
        name = user_names[user_id]
        greeting = (
            f"¬°Hola otra vez, {name}! üò∫ ¬°Qu√© alegr√≠a tenerte de vuelta!\n\n"
            "Estoy aqu√≠, listo para seguir siendo tu compa√±ero para organizar esas ideas geniales y ayudarte a alcanzar todas tus metas. ¬°Vamos con todo! üí™üèÜüí°"
        )
        # Usuario recurrente - usar imagen de bienvenida
        send_message_with_image(
            message.chat.id,
            greeting,
            RICH_WELCOME_IMG,
            reply_markup=make_main_menu(name),
            parse_mode="Markdown"
        )

@bot.message_handler(commands=['backup'])
def manual_backup(message):
    """Permite a un administrador forzar un respaldo manualmente"""
    # En un sistema real, deber√≠as verificar si el usuario es administrador
    # Por simplicidad, permitimos que cualquier usuario ejecute el comando
    user_id = message.from_user.id
    if user_id in user_names:
        bot.send_message(
            message.chat.id,
            "‚è≥ Realizando respaldo manual de los datos...",
            parse_mode="Markdown"
        )
        if save_backup(True):  # Forzar rotaci√≥n
            # Usar imagen de √©xito para el respaldo exitoso
            send_message_with_image(
                message.chat.id,
                "‚úÖ Respaldo completado correctamente.\n"
                f"üìä Usuarios: {len(user_names)}, Notas: {sum(len(notes) for notes in user_notes.values())}",
                RICH_SUCCESS_IMG,
                parse_mode="Markdown"
            )
        else:
            # Usar imagen triste para el error
            send_message_with_image(
                message.chat.id,
                "‚ùå Error al realizar el respaldo manual.",
                RICH_SAD_IMG,
                parse_mode="Markdown"
            )

# --- CALLBACK QUERIES MODIFICADO PARA VISTA DE TARJETAS ---
@bot.callback_query_handler(func=lambda call: True)
def callback_query(call):
    user_id = call.from_user.id
    name = user_names.get(user_id, "amigo")
    data = call.data

    if data == "add_note":
        prompt = (
            f"¬°Excelente, {name}! üòä Ahora, para que puedas organizar tus ideas de la mejor manera, elige una etiqueta para tu nueva nota: üòº\n\n"
            "¬øEn qu√© categor√≠a te gustar√≠a guardarla? ‚Äãüí≠"
        )
        # Usar imagen pensativa al iniciar creaci√≥n de nota
        send_message_with_image(
            call.message.chat.id,
            prompt,
            RICH_THINKING_IMG,
            reply_markup=make_tags_menu(),
            parse_mode="Markdown"
        )

    elif data.startswith("tag"):
        tag = data[3:]  # Asumiendo que "tag" tiene 3 caracteres
        user_temp[user_id] = {"pending_tag": tag}
        msg_text = (
            f"¬°Perfecto! ‚ú® La etiqueta '{tag}' {TAG_ICONS.get(tag, 'üîñ')} ha sido seleccionada. ¬°Excelente elecci√≥n! ‚úÖ\n\n"
            f"Y ahora, {name}, ¬øqu√© t√≠tulo le pondr√°s a esta incre√≠ble nota? üìå ¬°Estoy ansioso por ver tus ideas! ‚ú®"
        )
        # Usar imagen pensativa mientras espera el t√≠tulo
        msg = send_message_with_image(
            call.message.chat.id,
            msg_text,
            RICH_THINKING_IMG,
            parse_mode="Markdown"
        )
        bot.register_next_step_handler(msg, process_note_title)

    elif data == "show_notes":
        # FUNCIONALIDAD: Vista de tarjetas por etiquetas para VER notas
        tags_menu = make_tags_view_menu(user_id)
        
        if not tags_menu:
            bot.answer_callback_query(
                call.id,
                "üì≠ No hay notas registradas. ¬°Inicia tu primera nota cuando gustes! ‚ú®",
                show_alert=True
            )
            # Usar imagen triste cuando no hay notas
            send_message_with_image(
                call.message.chat.id,
                "üì≠ No hay notas registradas. ¬°Inicia tu primera nota cuando gustes! ‚ú®",
                RICH_SAD_IMG,
                parse_mode="Markdown",
                reply_markup=make_main_menu(name)
            )
        else:
            # Mostrar vista de etiquetas con tarjetas interactivas
            send_message_with_image(
                call.message.chat.id,
                f"üìÇ ¬°Hola, {name}! üòä Aqu√≠ tienes todas tus etiquetas organizadas.\n\n"
                "Selecciona una etiqueta para ver todas las notas que has guardado en esa categor√≠a: ‚ú®",
                RICH_SUCCESS_IMG,
                reply_markup=tags_menu,
                parse_mode="Markdown"
            )

    elif data.startswith("view_tag_"):
        # FUNCIONALIDAD: Mostrar notas de una etiqueta espec√≠fica para VER
        tag = data[9:]  # Remover "view_tag_"
        notes_menu = make_notes_by_tag_menu(user_id, tag)
        
        if not notes_menu:
            send_message_with_image(
                call.message.chat.id,
                f"üòÖ No se encontraron notas en la etiqueta '{tag}'. ¬°Parece que algo sali√≥ mal!",
                RICH_SAD_IMG,
                reply_markup=make_main_menu(name),
                parse_mode="Markdown"
            )
        else:
            tag_icon = TAG_ICONS.get(tag, "üîñ")
            notas_en_tag = [nota for nota in user_notes.get(user_id, []) if nota['tag'] == tag]
            
            send_message_with_image(
                call.message.chat.id,
                f"üìù {tag_icon} **Etiqueta: {tag}**\n\n"
                f"¬°Perfecto, {name}! Tienes **{len(notas_en_tag)}** nota(s) en esta categor√≠a.\n"
                "Selecciona cualquier nota para ver su contenido completo: üëá",
                RICH_SUCCESS_IMG,
                reply_markup=notes_menu,
                parse_mode="Markdown"
            )

    elif data.startswith("view_note_"):
        # FUNCIONALIDAD: Mostrar nota completa
        note_id = data[10:]  # Remover "view_note_"
        note = find_note_by_id(user_id, note_id)
        
        if not note:
            send_message_with_image(
                call.message.chat.id,
                f"üòÖ Lo siento, {name}, no pude encontrar esa nota. ¬°Puede que haya ocurrido un error!",
                RICH_SAD_IMG,
                reply_markup=make_main_menu(name),
                parse_mode="Markdown"
            )
        else:
            # Mostrar la nota completa con botones de navegaci√≥n
            formatted_note = format_full_note(note)
            
            # Crear botones de navegaci√≥n
            nav_kb = types.InlineKeyboardMarkup()
            nav_kb.add(types.InlineKeyboardButton(
                f"‚Ü©Ô∏è Volver a {note['tag']}", 
                callback_data=f"view_tag_{note['tag']}"
            ))
            nav_kb.add(types.InlineKeyboardButton(
                "üìÇ Ver todas las etiquetas", 
                callback_data="show_notes"
            ))
            nav_kb.add(types.InlineKeyboardButton(
                "üè† Men√∫ principal", 
                callback_data="back_to_main"
            ))
            
            send_message_with_image(
                call.message.chat.id,
                formatted_note,
                RICH_SUCCESS_IMG,
                reply_markup=nav_kb,
                parse_mode="Markdown"
            )

    elif data == "delete_note":
        # NUEVA FUNCIONALIDAD: Vista de tarjetas por etiquetas para ELIMINAR notas
        delete_tags_menu = make_delete_tags_menu(user_id)
        
        if not delete_tags_menu:
            bot.answer_callback_query(
                call.id,
                "¬°Hola! üòä Parece que Rich IA a√∫n no tiene notas para eliminar. ¬°An√≠mate a escribir algo cuando tengas una idea! ‚ú®",
                show_alert=True
            )
            # Usar imagen triste cuando no hay notas para eliminar
            send_message_with_image(
                call.message.chat.id,
                f"¬°Hola, {name}! üòä Parece que a√∫n no tienes notas para eliminar. ¬°An√≠mate a crear una cuando tengas alguna idea! ‚ú® ¬°Estoy aqu√≠ para ayudarte!",
                RICH_SAD_IMG,
                reply_markup=make_main_menu(name),
                parse_mode="Markdown"
            )
        else:
            # Mostrar vista de etiquetas con tarjetas interactivas para eliminaci√≥n
            send_message_with_image(
                call.message.chat.id,
                f"üóëÔ∏è ¬°Entendido, {name}! üëå Aqu√≠ tienes todas tus etiquetas organizadas.\n\n"
                "Selecciona la etiqueta de la cual deseas eliminar una nota: üéØ",
                RICH_THINKING_IMG,
                reply_markup=delete_tags_menu,
                parse_mode="Markdown"
            )

    elif data.startswith("delete_tag_"):
        # NUEVA FUNCIONALIDAD: Mostrar notas de una etiqueta espec√≠fica para ELIMINAR
        tag = data[11:]  # Remover "delete_tag_"
        delete_notes_menu = make_delete_notes_by_tag_menu(user_id, tag)
        
        if not delete_notes_menu:
            send_message_with_image(
                call.message.chat.id,
                f"üòÖ No se encontraron notas en la etiqueta '{tag}' para eliminar. ¬°Parece que algo sali√≥ mal!",
                RICH_SAD_IMG,
                reply_markup=make_main_menu(name),
                parse_mode="Markdown"
            )
        else:
            tag_icon = TAG_ICONS.get(tag, "üîñ")
            notas_en_tag = [nota for nota in user_notes.get(user_id, []) if nota['tag'] == tag]
            
            send_message_with_image(
                call.message.chat.id,
                f"üóëÔ∏è {tag_icon} **Etiqueta: {tag}**\n\n"
                f"¬°Perfecto, {name}! Tienes **{len(notas_en_tag)}** nota(s) en esta categor√≠a.\n\n"
                "‚ö†Ô∏è **¬°Cuidado!** Selecciona la nota que deseas eliminar permanentemente: üëá\n"
                "üí° *Tip: Una vez eliminada, no podr√°s recuperarla.*",
                RICH_THINKING_IMG,
                reply_markup=delete_notes_menu,
                parse_mode="Markdown"
            )

    elif data.startswith("confirm_delete_"):
        # NUEVA FUNCIONALIDAD: Confirmar eliminaci√≥n de nota espec√≠fica
        idx = int(data[15:])  # Remover "confirm_delete_"
        notas = user_notes.get(user_id, [])
        
        if 0 <= idx < len(notas):
            deleted_note = notas.pop(idx)
            bot.answer_callback_query(
                call.id, 
                "¬°Hecho! ‚úÖ ¬°Nota eliminada exitosamente! üéâ", 
                show_alert=True
            )
            
            # Guardar respaldo despu√©s de eliminar
            if SAVE_ON_CHANGES:
                save_backup()

            # Mostrar confirmaci√≥n con detalles de la nota eliminada
            tag_icon = TAG_ICONS.get(deleted_note['tag'], "üîñ")
            confirmation_text = (
                f"‚úÖ **¬°Eliminaci√≥n exitosa!** ‚úÖ\n\n"
                f"La siguiente nota ha sido eliminada permanentemente:\n\n"
                f"üìå **T√≠tulo:** {deleted_note['title']}\n"
                f"{tag_icon} **Etiqueta:** {deleted_note['tag']}\n"
                f"üïí **Fecha:** {deleted_note['ts'].strftime('%Y-%m-%d %H:%M')}\n\n"
                f"¬°Listo, {name}! Tu espacio est√° un poquito m√°s organizado. üåü"
            )
            
            # Crear men√∫ de navegaci√≥n post-eliminaci√≥n
            post_delete_kb = types.InlineKeyboardMarkup()
            post_delete_kb.add(types.InlineKeyboardButton(
                "üóëÔ∏è Eliminar otra nota", 
                callback_data="delete_note"
            ))
            post_delete_kb.add(types.InlineKeyboardButton(
                "üè† Men√∫ principal", 
                callback_data="back_to_main"
            ))
            
            send_message_with_image(
                call.message.chat.id,
                confirmation_text,
                RICH_SUCCESS_IMG,
                reply_markup=post_delete_kb,
                parse_mode="Markdown"
            )
        else:
            # Error al eliminar
            send_message_with_image(
                call.message.chat.id,
                f"‚ùå {name}, hubo un error al eliminar la nota. Por favor, int√©ntalo de nuevo. ‚ö†Ô∏è",
                RICH_SAD_IMG,
                parse_mode="Markdown",
                reply_markup=make_main_menu(name)
            )

    elif data == "search_note":
        # Usar imagen pensativa para la b√∫squeda
        msg = send_message_with_image(
            call.message.chat.id,
            f"¬°Claro, {name}! üòä Para encontrar tus notas por fecha, ¬øpodr√≠as decirme qu√© d√≠a buscas en formato AAAA-MM-DD? üìÖ ¬°As√≠ podr√© ayudarte mejor!",
            RICH_THINKING_IMG,
            parse_mode="Markdown"
        )
        bot.register_next_step_handler(msg, process_search_date)

    elif data == "about_me":
        about_text = (
            "¬°Hola! üëã Somos el Equipo IODs (Index of Dreams), un grupo de personas con un sue√±o: crear herramientas que te hagan la vida m√°s f√°cil. ‚ú®\n\n"
            "Gracias por ser parte de la aventura Rich IA. ¬°Tu confianza nos impulsa a seguir creando cosas incre√≠bles para ti! üòäüôè\n\n"
            "¬°Con√©ctate con nosotros en nuestras redes! Nos encanta saber de ti\n"
            "¬°Nuestra pagina web! üòâ‚Äãüåê‚Äã\n"
            "‚Ä¢ üëÄ Vistamos: https://sites.google.com/est.umss.edu/iods/inicio\n"
            "¬°Nuestras redes sociales! ü´Ç‚Äãüìù‚Äã\n"
            "‚Ä¢ üê¶ Tiktok: https://tiktok.com/@iods.index\n"
            "‚Ä¢ üíª Facebook: https://www.facebook.com/iods.index\n"
            "‚Ä¢ üì∏ Instagram: https://www.instagram.com/iods.index?igsh=aTZhOGR1eG1jZDh5\n\n"
            "¬°Juntos so√±amos m√°s grande! üöÄ ¬°Gracias por tu apoyo! üíñ"
        )
        # Usar imagen de bienvenida para el apartado "Sobre m√≠"
        send_message_with_image(
            call.message.chat.id,
            about_text,
            RICH_WELCOME_IMG,
            parse_mode="Markdown",
            reply_markup=make_main_menu(name)
        )

    elif data == "back_to_main":
        # Usar imagen de bienvenida para el men√∫ principal
        send_message_with_image(
            call.message.chat.id,
            f"¬°Hola, {name}! üòä ¬°Qu√© alegr√≠a tenerte por aqu√≠!\n\n"
            "Soy Rich IA, tu compa√±ero virtual listo para ayudarte a organizar tus ideas y ser tu apoyo en el d√≠a a d√≠a. üíñ\n"
            "Imagina este espacio como tu bloc de notas personal donde cada pensamiento es bienvenido y cuidado. ‚ú®\n\n"
            "¬øQu√© te gustar√≠a hacer hoy? ¬°Estoy aqu√≠ para escucharte! ü§ó",
            RICH_WELCOME_IMG,
            parse_mode="Markdown",
            reply_markup=make_main_menu(name)
        )

# --- FUNCIONES DE PROCESO DE T√çTULO Y CONTENIDO MODIFICADAS ---
def process_note_title(message):
    user_id = message.from_user.id
    name = user_names.get(user_id, "amigo")
    title = message.text.strip()
    if not title:
        # Usar imagen triste para el error
        msg = send_message_with_image(
            message.chat.id,
            "¬°Mmm, parece que hubo un peque√±o problema con el t√≠tulo! ü§î ¬øPodr√≠as ingresarlo de nuevo, por favor? üòä ¬°As√≠ tu nota quedar√° perfectamente organizada!",
            RICH_SAD_IMG,
            parse_mode="Markdown"
        )
        bot.register_next_step_handler(msg, process_note_title)
        return
    user_temp[user_id]['pending_title'] = title
    msg_text = (
        f"¬°Genial, {name}! üòä El t√≠tulo '{title}' qued√≥ perfecto. ‚úÖ ¬°Ya casi estamos!\n\n"
        "Ahora, cu√©ntame, ¬øqu√© quieres plasmar en esta nota tan importante? üìù ¬°Estoy listo para leerte! ‚ú®\n\n"
        "üí° **Tip:** Puedes escribir hasta 2000 caracteres para que tu nota sea s√∫per completa."
    )
    # Usar imagen pensativa mientras espera el contenido
    msg = send_message_with_image(
        message.chat.id,
        msg_text,
        RICH_THINKING_IMG,
        parse_mode="Markdown"
    )
    bot.register_next_step_handler(msg, process_note_content)

def process_note_content(message):
    user_id = message.from_user.id
    name = user_names.get(user_id, "amigo")
    content = message.text.strip()
    temp = user_temp.get(user_id, {})
    tag = temp.get('pending_tag')
    title = temp.get('pending_title')
    
    if not tag or not title:
        # Usar imagen triste para el error
        send_message_with_image(
            message.chat.id,
            "‚ùå Ha ocurrido un error. Regresando al men√∫ principal.",
            RICH_SAD_IMG,
            reply_markup=make_main_menu(name),
            parse_mode="Markdown"
        )
        return
    
    if not content:
        # Usar imagen triste para el error
        msg = send_message_with_image(
            message.chat.id,
            "¬°Un momento! üòä Parece que el contenido de tu nota est√° vac√≠o. ¬øPodr√≠as agregar algunas ideas o detalles? üìù ¬°Estoy seguro de que tienes algo genial para escribir!",
            RICH_SAD_IMG,
            parse_mode="Markdown"
        )
        bot.register_next_step_handler(msg, process_note_content)
        return
    
    # Validar longitud del contenido (aumentado a 2000 caracteres)
    if len(content) > 2000:
        msg = send_message_with_image(
            message.chat.id,
            f"¬°Wow, {name}! üòä Tu nota es s√∫per completa, pero es un poquito larga. üìù\n\n"
            f"Actualmente tiene {len(content)} caracteres, pero el l√≠mite es de 2000. ¬øPodr√≠as acortarla un poco? ¬°Gracias! ‚ú®",
            RICH_THINKING_IMG,
            parse_mode="Markdown"
        )
        bot.register_next_step_handler(msg, process_note_content)
        return
    
    nota = {"tag": tag, "title": title, "text": content, "ts": datetime.now()}
    user_notes.setdefault(user_id, []).append(nota)
    user_temp.pop(user_id, None)

    # Guardar respaldo despu√©s de a√±adir una nota
    if SAVE_ON_CHANGES:
        save_backup()

    # Crear formato para la nueva nota
    note_formatted = format_note(nota)

    final_msg = (
        f"¬°Felicidades, {name}! üéâ Tu nota ha sido guardada exitosamente. ¬°Qu√© bien! üòä\n\n"
        f"Aqu√≠ est√° tu creaci√≥n:\n\n"
        f"{note_formatted}\n\n"
        f"üìä **Estad√≠sticas:** {len(content)} caracteres utilizados de 2000 disponibles.\n\n"
        "¬°Gracias por permitirme ser parte de esto! ¬°Conf√≠a siempre en Rich IA! üåü ¬°Estoy aqu√≠ para ti! ü§ó"
    )
    # Usar imagen de √©xito al guardar la nota
    send_message_with_image(
        message.chat.id,
        final_msg,
        RICH_SUCCESS_IMG,
        parse_mode="Markdown",
        reply_markup=make_main_menu(name)
    )

# --- FUNCIONES DE PROCESO DE FECHA ---
def process_search_date(message):
    user_id = message.from_user.id
    name = user_names.get(user_id, "amigo")
    date_str = message.text.strip()
    try:
        search_date = datetime.strptime(date_str, "%Y-%m-%d").date()
    except ValueError:
        msg = bot.send_message(
            message.chat.id,
            "¬°Ups! üòÖ Parece que el formato de la fecha no es el correcto. Por favor, aseg√∫rate de usar el formato AAAA-MM-DD. üôè ¬°As√≠ podremos buscar tu nota sin problemas! üìÖ",
        )
        bot.register_next_step_handler(msg, process_search_date)
        return
    notas = user_notes.get(user_id, [])
    filtered = [n for n in notas if n['ts'].date() == search_date]

    # Usar formato mejorado para los resultados de b√∫squeda
    formatted_results = create_search_results(filtered, date_str, name)
    bot.send_message(
        message.chat.id,
        formatted_results,
        parse_mode="Markdown"
    )

    bot.send_message(
        message.chat.id,
        "¬øQu√© nuevas ideas tienes en mente ahora? üí° ¬°Cu√©ntame! üëá",
        reply_markup=make_main_menu(name)
    )

# Agregar esto al final de tu archivo, justo antes del bloque "if __name__ == "__main__":"
def setup_web_server():
    """Configura un servidor web simple para mantener el servicio activo en Render"""
    try:
        from flask import Flask, jsonify
        import threading
        
        app = Flask(__name__)
        
        @app.route('/')
        def index():
            stats = {
                "status": "activo",
                "usuarios": len(user_names),
                "notas_totales": sum(len(notes) for notes in user_notes.values()),
                "timestamp": datetime.now().strftime("%Y-%m-%d %H:%M:%S"),
                "version": "Rich AI v1.0"
            }
            return f"""
            ¬°Rich AI est√° activo! üöÄ<br>
            Status: {stats['status']}<br>
            Usuarios: {stats['usuarios']}<br>
            Notas: {stats['notas_totales']}<br>
            √öltima actualizaci√≥n: {stats['timestamp']}
            """
        
        @app.route('/health')
        def health():
            return jsonify({
                "status": "OK", 
                "timestamp": datetime.now().isoformat(),
                "service": "Rich AI Bot"
            }), 200
        
        @app.route('/ping')
        def ping():
            return jsonify({"response": "pong", "timestamp": datetime.now().isoformat()}), 200
        
        # Configuraci√≥n de puerto m√°s robusta
        port = int(os.environ.get("PORT", 10000))  # Render usa 10000 por defecto
        
        def run_server():
            # Configuraci√≥n de producci√≥n para Render
            app.run(
                host="0.0.0.0", 
                port=port, 
                debug=False, 
                use_reloader=False,
                threaded=True  # Importante para manejar m√∫ltiples requests
            )
        
        # Iniciar el servidor web en un hilo separado
        server_thread = threading.Thread(target=run_server, daemon=True)
        server_thread.start()
        print(f"üåê Servidor web iniciado en 0.0.0.0:{port}")
        
        # Esperar un momento para que el servidor se inicie
        time.sleep(2)
        return True
        
    except ImportError as e:
        print(f"‚ö†Ô∏è Error de importaci√≥n: {e}")
        print("‚ö†Ô∏è Para desplegar en Render, aseg√∫rate de tener Flask en requirements.txt")
        return False
    except Exception as e:
        print(f"‚ùå Error al iniciar servidor web: {e}")
        return False

# --- INICIAR POLLING ---

# Modificar la secci√≥n final del c√≥digo:
if __name__ == "__main__":
    print("üöÄ Rich AI arrancando...")
    load_dotenv()
    load_backup()
    save_backup()

    # Iniciar servidor web para Render (SOLO UNA VEZ)
    web_server_started = setup_web_server()
    
    # Iniciar hilo para respaldos autom√°ticos
    backup_thread = threading.Thread(target=backup_scheduler, daemon=True)
    backup_thread.start()
    
    # Iniciar hilo para keep-alive solo si el servidor web se inici√≥ correctamente
    if web_server_started:
        keep_alive_thread = threading.Thread(target=keep_alive_scheduler, daemon=True)
        keep_alive_thread.start()
        print("üîÑ Sistema keep-alive iniciado")
    else:
        print("‚ö†Ô∏è Keep-alive no iniciado - servidor web no disponible")

    try:
        bot.infinity_polling()
    except KeyboardInterrupt:
        print("üõë Apagado manual detectado. Guardando respaldo final...")
        save_backup(True)
        print("‚úÖ Respaldo final completado. ¬°Hasta pronto! üëã")
    except Exception as e:
        print(f"‚ùå Error cr√≠tico: {e}")
        print("‚ö†Ô∏è Intentando guardar respaldo de emergencia...")
        save_backup(True)
